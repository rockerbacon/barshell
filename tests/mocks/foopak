#!/bin/bash
export project_root
until [ -d ".git" ]; do
echo "$PWD" >&2
if [ ! -O . ] || [ "$PWD" == "/" ]; then
echo "ERROR: Project root directory could not be found." >&2
exit 1
fi
cd ..
done
project_root=$PWD
export escaped_project_root
escaped_project_root=$(echo "$project_root" | sed 's/\//\\\//g')
print_locate_cmd_help() {
cat >&2 <<EOF
Usage: ./foopak locate-cmd [OPTIONS...] COMMAND
Scan installed modules to locate a command

COMMAND:	command to be located

OPTIONS:
	--absolute-path	print absolute path to the command
			instead of the relative path

	--exclude-dir	ignore a specific directory
			when searching for the command.
			Directory is relative to the root of the project

	--print-module	print path to the module
			instead of the path to the script
			which implements the command

	--help,-h	print this help message and exit
EOF
}
locate_cmd() {
extra_tests=()
reading_named_args=true
while [ "$reading_named_args" == "true" ]; do
option=$1
case "$option" in
--exclude-dir)
extra_tests+=("-not -path '$project_root/$2/*'"); shift 2
;;
--help|-h)
print_locate_cmd_help
return 0
;;
--*|-*)
echo "ERROR: unknown option '$option'" >&2
return 1
;;
*)
reading_named_args=false
;;
esac
done
command_name=$1; shift
if [ ! -d "$project_root/foopak_modules" ]; then
echo "WARN: no modules installed" >&2
return 1
fi
find_query=" \
find '$project_root/foopak_modules' \
${extra_tests[*]} \
-path '*/foopak_meta/*' \
-name command_list.conf \
-exec	grep --with-filename -E '^$command_name\s' {} + \
"
command_config_line=$(bash -c "$find_query")
if [ -z "$command_config_line" ]; then
return 1
fi
config_file=${command_config_line%%:*}
declare -a config="(${command_config_line#*:})"
module_root=$(realpath "$(dirname "$config_file")/../")
module_name=${module_root#$project_root/foopak_modules/}
i=1
command_type=${config[$i]}
case "$command_type" in
_alias_)
((i++))
cmd=("${BASH_SOURCE[0]}" "${config[@]:$i}")
;;
_executable_)
((i++))
;&
*)
cmd=("$module_root/${config[$i]}")
;;
esac
echo "([module_name]='$module_name' [module_root]='$module_root' [cmd]=\"(${cmd[@]@Q})\")"
}
print_remove_help() {
cat >&2 << EOF
Usage: ./foopak remove [OPTIONS...] MODULE
Remove module located in path 'foopak_modules/MODULE'

MODULE:		module to remove
		use './foopak list' to see all installed modules

OPTIONS:
	--dir,-d	remove module under different directory
			default is foopak_modules

	--help,-h	print this help message and exit
EOF
}
remove() {
module_home_relative_dir="foopak_modules"
reading_named_args=true
while [ "$reading_named_args" == "true" ]; do
option=$1
case "$option" in
--dir|-d)
module_home_relative_dir=$2; shift 2
;;
--help|-h)
print_remove_help
exit 0
;;
--*|-*)
echo "ERROR: Unknown option '$option'" >&2
echo >&2
print_remove_help >&2
exit 1
;;
*)
reading_named_args=false
;;
esac
done
module_alias=$1; shift
if [ -z "$module_alias" ]; then
echo "ERROR: please specify the module to remove" >&2
echo >&2
print_remove_help
exit 1
fi
module_relative_dir="$module_home_relative_dir/$module_alias"
module_dir="$project_root/$module_relative_dir"
if [ ! -d "$module_dir" ]; then
echo "ERROR: module '$module_alias' not installed" >&2
echo >&2
print_remove_help
exit 1
fi
git submodule deinit -f "$module_dir"
git rm -f "$module_dir"
rm -rf "$project_root/.git/modules/$module_relative_dir"
}
print_add_help() {
cat >&2 << EOF
Usage: ./foopak add [OPTIONS...] MODULE
Add module located in path MODULE from a git server to the project

MODULE:		path where the module resides in the git server. eg.:
		'rockerbacon/foopak-mock-module' adds the module from
		https://github.com/rockerbacon/foopak-mock-module

OPTIONS:
	--alias,-a	use different folder name for module
			default is MODULE with slashes
			replaced by underscores

	--tag,-t,	use specific tag or commit
	--commit,-c	default is the latest commit in the default remote

	--dir,-d	add module under different directory
			default is foopak_modules
			WARNING:
				modules outside 'foopak_modules'
				will not be scanned for commands

	--branch,-b	use specific branch
			default is the default remote branch

	--help,-h	print this help message and exit

EOF
}
add() {
git_server="https://github.com"
module_home_relative_dir="foopak_modules"
module_options=()
reading_named_args=true
while [ "$reading_named_args" == "true" ]; do
option=$1
case "$option" in
--alias|-a)
module_alias=$2; shift 2
;;
--branch|-b)
module_options+=("-b" "$2"); shift 2
;;
--commit|-c|--tag|-t)
module_version=$2; shift 2
;;
--dir|-d)
module_home_relative_dir=$2; shift 2
;;
--help|-h)
print_add_help
return 0
;;
--*|-*)
echo "ERROR: Unknown option '$option'" >&2
echo >&2
print_add_help >&2
return 1
;;
*)
reading_named_args=false
;;
esac
done
module_path=$1; shift
if [ "$module_path" == "" ]; then
echo "ERROR: please specify a module to add" >&2
echo >&2
print_add_help
return 1
fi
if [ -z "$module_alias" ]; then
module_alias=$module_path
fi
module_parent_dir=$(dirname "$module_alias")
if [ "${module_parent_dir:0:1}" != "." ]; then
mkdir -p "$project_root/$module_parent_dir"
fi
module_install_path="$module_home_relative_dir/$module_alias"
if [ -e "$module_install_path" ]; then
echo "ERROR: could not add module: directory '$module_install_path' already exists" >&2
return 1
fi
cd "$project_root" || return 1
git submodule add "${module_options[@]}" "$git_server/$module_path" "$module_install_path"
if [ -n "$module_version" ]; then
restore_workdir=$PWD
cd "$project_root/$module_install_path" || return 1
git checkout "$module_version"; exit_status=$?
cd "$restore_workdir" || return 1
if [ "$exit_status" != "0" ]; then
echo "ERROR: could not checkout version '$module_version', rolling back" >&2
remove "$module_alias"
return 1
fi
fi
command_list="$module_install_path/foopak_meta/command_list.conf"
if [ -f "$command_list" ]; then
exec 3< "$command_list"
command_list_version=$(read -ru 3)
while read -ru 3 command_config || [ -n "$command_config" ]; do
[ -z "$command_config" ] && continue
[ "${command_config:0:1}" == "#" ] && continue
command_name=${command_config%%[[:space:]]*}
locate_output=$(locate_cmd --exclude-dir "$module_install_path" "$command_name")
found_command=$?
if [ "$found_command" == "0" ]; then
declare -A command_config="$locate_output"
echo "ERROR: could not add module: command '$command_name' conflicts with module '${command_config[module_name]}'" >&2
remove "$module_alias"
return 1
fi
done
exec 3>&-
fi
}
exec_module_cmd() {
command_name=$1; shift
locate_output=$(locate_cmd "$command_name")
found_command=$?
if [ "$found_command" == "1" ]; then
echo "ERROR: unknown command '$command_name'" >&2
return 1
fi
declare -A command_config="$locate_output"
declare -a cmd="${command_config[cmd]}"
module_root="${command_config[1]}" "${cmd[@]}" "$@"
return $?
}
main() {
command=$1; shift
case "$command" in
remove|r)
remove "$@"
;;
add|a)
add "$@"
;;
locate-cmd)
locate_cmd "$@"
;;
*)
exec_module_cmd "$command" "$@"
;;
esac
}
main "$@"
